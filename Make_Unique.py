#will generate a dictionary for each sample, where each V gene is a key, and values are count, then relative count of each J_gene


from bisect import bisect_left
import cPickle as pickle

#location = '/Users/haochuhuang/Documents/Jason Perera/3H9 BCR HTS Sequencing/compile IMGT Summary/O1-SP.txt'
location = '/Users/haochuhuang/Documents/Jason Perera/3H9 BCR HTS Sequencing/compile IMGT Summary/' 
names = ['O1-SP', 'O1-THY', 'Y1-SP', 'Y1-THY', 'O2-SP', 'O2-THY', 'Y2-SP', 'Y2-THY', 'O3-SP', 'O3-THY', 'Y3-SP', 'Y3-THY', 'O4-SP', 'O4-THY', 'Y4-SP', 'Y4-THY', 'O5-SP', 'O5-THY', 'Y5-SP', 'Y5-THY']
names2 = ['SP-O1', 'SP-O2', 'SP-O3', 'SP-O4', 'SP-O5', 'SP-Y1', 'SP-Y2', 'SP-Y3', 'SP-Y4', 'SP-Y5', 'THY-O1', 'THY-O2', 'THY-O3', 'THY-O4', 'THY-O5', 'THY-Y1', 'THY-Y2', 'THY-Y3', 'THY-Y4', 'THY-Y5']


def CDR3_usage(f):
    '''file --> list of 
takes a file open for reading, reads through each line of IMGT sequence, finds the V-gene used, and increments the value of that gene
in the V_genes_dict by one, then returns that dictionary'''
    f.readline()
    List = []
    for line in f:
        a = line.split('\t')
        if a[2] == 'productive':                              #if it is a productive rearrangement
            reads = int(a[1].split('-')[1])
            V_gene = a[3].split('*')[0].strip('Musmus ')
            J_gene = a[9].split()[1].split('*')[0]       #gets J_gene segment minus additional nomenclature
            CDR3 = (a[20])   #gets the IgV region, before the allele nomenclature '*' and after the species nomenclature 'Musmus'
            List.append((CDR3, V_gene, J_gene, reads))
    f.close()     #closes the file 
    return List


def compare_overlap(a, b):
    end = len(b)
    count = 0
    for item in a:
        pos = bisect_left(b, item)
        if pos < end:
            if b[pos] == item:
                count = count + 1
    return count            




def scan(count, l):
    '''int, list of tup --> nothing (modifies a list)
takes a index of a given list, and scans the entries that immediately follow it.  while they are identical, it accumulates the number of reads,
removes the identical entries from the list, and once the next entry is no longer identical, it replaces the initial entry with an updated entry
reflecting the total number of counts from all the identical sequences'''

    CDR3, Vgene, Jgene, reads = l[count]
    
    while count<(len(l)-1) and l[count][:3] == l[count+1][:3]:
        reads = reads + l[count+1][3]
        l.pop(count + 1)
    l[count] = (CDR3, Vgene, Jgene, reads)
        


def unique(l):
    '''list of tup --> list of tup
takes the list of tuples generated by CDR3 usage, and then combines them so that samples with the same CDR3, V-gene, J-gene are compressed into
one entry, with their number of reads combined.'''
    count = 0
    for item in l:
        scan(count, l)
        count = count + 1
    print count
    


d = {}
e = {}
for item in names:
    file1 = open(location + item + '.txt', 'r')
    new_list = CDR3_usage(file1)
    new_list.sort()
    d[str(item[3:] + '-' + item[:2])] = new_list      #rearranges file names to a more easily sortable name
    unique(new_list)
    e[str(item[3:] + '-' + item[:2])] = new_list
    print (item + ' is complete')
    
